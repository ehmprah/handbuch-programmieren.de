(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{280:function(e,n,t){"use strict";t.r(n);var i=t(16),r=Object(i.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Hinter dem etwas sperrigen Namen dieses Paradigmas bzw. architektonischen Musters verstecken sich einige simple und sympatische Prinzipien, mit denen wir eine Reihe von Schmerzen bei der Programmierung mit OOP und anderen Paradigmen beheben wollen. Entity Component System legt zum Beispiel Wert auf die Trennung von Daten und Logik und zieht einfache Komposition komplexen Hierarchien vor. Was das im Detail bedeutet, werden wir uns nach einer grundlegenden Definition im Folgenden anschauen.")]),e._v(" "),n("h2",{attrs:{id:"der-name-ist-programm"}},[e._v("Der Name ist Programm")]),e._v(" "),n("p",[e._v("Der Name Entity Component System beinhaltet bereits alle wesentlichen Bestandteile dieses Paradigmas. Eine "),n("em",[e._v("Entity")]),e._v(" ist in diesem Sinne nicht mehr als ein Container für Daten und besteht lediglich aus einer einzigartigen ID und der Fähigkeit, mit "),n("em",[e._v("Components")]),e._v(" versehen werden zu können; diese beinhalten dann die eigentlichen Daten unserer Applikation. Die Logik unserer Applikation lebt schließlich in einem oder mehreren "),n("em",[e._v("Systems")]),e._v(",  die über unsere Entitäten iterieren und interagieren, je nach deren Komponenten.")]),e._v(" "),n("p",[e._v('Zum Beispiel könnten wir uns eine Applikation vorstellen, in der eine Reihe von "Menschen" leben; diese sind dann Entitäten mit einer ID und zum Beispiel der Komponente "Alter". Das System "Zeit" würde nun über alle Menschen iterieren und regelmäßig ihr Alter erhöhen.')]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" entities "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[e._v("id")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[e._v("components")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[e._v("age")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("time")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  entities"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("forEach")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("entity")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("entity"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("components"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("age "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!==")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("undefined")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v("entity"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("components"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("age"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("h2",{attrs:{id:"daten-und-logik-gesellen-sich-nicht-gern"}},[e._v("Daten und Logik gesellen sich nicht gern")]),e._v(" "),n("p",[e._v('Diese Trennung von Daten und Logik macht unseren Code übersichtlicher und damit leichter zu debuggen, zu warten und zu erweitern. Wir müssen nicht an verschiedenen Stellen suchen und Anpassungen machen: bei diesem Paradigma ist unser Code per se bestens organisiert. Natürlich kann man auch hier Schindluder treiben und zum Beispiel sämtliche Logik in ein System gießen, anstatt ein eigenes System für wenige sinnvoll zusammengehörige Komponenten zu schreiben – in unserem Beispiel von eben iteriert unser "Zeit"-System auch tatsächlich nur über die "Alter"-Komponente.')]),e._v(" "),n("p",[e._v("Aber selbst in diesem nicht optimalen Fall haben wir trotzdem eine Optimierung im Vergleich zur objektorientierten Programmierung, die uns keineswegs vorschreibt, welches Objekt welche Logik beinhalten darf, weswegen wir diese Freiheit gerne zu unserem eigenen Nachteil missbrauchen und unsere Logik gerne da unterbringen, wo sie uns gerade sinnvoll erscheint – und wir dann erst nach ewigem Suchen in einem halben Dutzend Objekten den Code wiederfinden, den wir bei einem Bugfix oder einer Erweiterung suchen.")]),e._v(" "),n("p",[e._v("Und da die Daten, mit denen wir arbeiten, tatsächlich auch nur Daten sind und keinerlei Logik beinhalten, können wir ganz einfach einen Stand festhalten, speichern, exportieren oder manipulieren, ohne unsere Applikation durcheinanderzubringen. Ich für meinen Teil wusste um diese Vorteile, war aber am Ende nach meinem ersten ECS-Projekt überrascht, wie wertvoll die Trennung zwischen Daten und Logik im Programmieralltag ist.")]),e._v(" "),n("h2",{attrs:{id:"komposition-statt-vererbung"}},[e._v("Komposition statt Vererbung")]),e._v(" "),n("p",[e._v('Und die Trennung von Daten und Logik ist beileibe nicht der einzige Pluspunkt bei ECS: mindestens genauso wertvoll und das eigentliche Killer-Feature im Vergleich zur objektorientierten Programmierung ist die Komposition. Da unsere Entities lediglich aus einer ID bestehen und aus verschiedenen Komponenten frei zusammengestellt – oder besser "komponiert" werden können, haben wir absolut keine Vererbung zu berücksichtigen und wir verrennen uns auch nicht in unnötig komplexe Hierarchie-Bäume.')]),e._v(" "),n("p",[e._v("Da es bei ECS nur gleichwertige Komponenten gibt, bekommen wir, wenn wir eine Banane wollen, auch tatsächlich nur eine Banane – und nicht auch noch den Gorilla, der die Banane hält und den ganzen Dschungel obenddrauf (was der Erlang-Erfinder Joe Armstrong der objektorientierten Programmierung humorvoll vorwarf).")]),e._v(" "),n("p",[e._v('Natürlich gibt es auch bei ECS Objekte im Sinne der OOP: also Entitäten, die eine bestimmte Kombination aus Komponenten haben, die ich im Folgenden mal Archetyp nenne. Wenn ich nun einen neuen Archetyp brauche, der alle Komponenten eines bestehenden Archetypen hat, bis auf eine einzige – dann kopiere ich den alten Archetyp, entferne die Komponente und bin fertig. In der objektorientierten Programmierung würde ich in diesem Falle meinen kompletten Hierarchie-Baum überarbeiten müssen: mein "Archetyp" bräuchte ein neues Objekt, von dem sowohl die alte Version, als auch die neue Variante erben können. Je nachdem wie tief Vererbungskette hier bereits wäre, bringen wir uns hier in Teufels Küche und haben jede Menge Arbeit umsonst zu erledigen. Natürlich haben wir dieses Problem nicht, wenn wir von Anfang an jedes Objekt in unserer Applikation kennen und einen perfekten Hierarchie- und Vererbungsbaum von Anfang an erstellen können. Aber in über zehn Jahren Software-Entwicklung in allen Farben und Formen ist mir so ein Projekt noch nicht untergekommen.')]),e._v(" "),n("h2",{attrs:{id:"es-ist-nicht-alles-gold-was-glanzt"}},[e._v("Es ist nicht alles gold was glänzt")]),e._v(" "),n("p",[e._v("Die Vorteile von ECS sind nicht von der Hand zu weisen: aber natürlich gibt's auch hier klare Nachteile. Zum einen lädt ECS dazu ein, imperformanten Code zu schreiben: da unser Ziel ist, Systeme mit einem möglichst kleinen Aufgabenbereich zu schreiben, werden wir zwangsläufig viele Systeme haben, die über alle Entities iterieren. Bei vielen System und Entities wird das schnell zum Performance-Problem. Zwar ist es durchaus möglich, diese Performance-Probleme zu vermeiden, aber dass wir uns hier eine von vielen "),n("a",{attrs:{href:"https://skypjack.github.io/2019-03-07-ecs-baf-part-2/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Strategien"),n("OutboundLink")],1),e._v(" aussuchen und diese bewusst anwenden müssen, ist ein klarer Nachteil.")]),e._v(" "),n("p",[e._v("Desweiteren sind die Anwendungsfelder für ECS wohl eher beschränkt: seinen Ursprung hat das Paradigma in der Spiele-Entwicklung und nicht umsonst findet es dort die meiste Verwendung. Viele andere Applikationen, die wir entwickeln, funktionieren eher nach dem Prinzip Aktion-Reaktion und haben gar keine Verwendung für Systeme, die dauerhaft über Daten iterieren. Dennoch denke ich dass die Vorteile, die ECS bietet, sehr wertvoll auch für andere Paradigmen und Applikationen sein kann: und am Ende gibt es auch hier wieder die Möglichkeit, nicht das ganze Paradigma zu übernehmen, sondern sich die Rosinen herauszupicken und das zu verwenden, was zu deinem konkreten Projekt passt.")]),e._v(" "),n("img",{attrs:{src:"https://vg09.met.vgwort.de/na/c052e287e07244588307a7b01cd1144f",width:"1",height:"1",alt:""}})])}),[],!1,null,null,null);n.default=r.exports}}]);